---
title   : "즉시로딩과 지연로딩"
categories : 
    - jpa
tags : 
    - java
    - spring
    - jpa
sidebar:
    title: "JPA"
    nav : sidebar-posts
---  


프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다고 했다.  

그러면 선수 엔티티를 조회할 때 해당 선수와 연관된 팀도 같이 데이터베이스에서 조회하는 것이 좋을까?  

아니면 해당 선수만 조회해 두고 팀 엔티티는 실제 사용되는 시점에 데이터베이스에서 조회하는 것이 좋을까?  

JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 두 가지 방법을 제공한다.  

#### 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.  

ex) em.find(Player.class, 1L); 를 호출할 때 선수 엔티티와 연관된 팀 엔티티도 함께 조회한다.  

설정 방법: @ManyToOne(fetch = FetchType.EAGER)  


#### 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.  

ex) player.getTeam().getName() 처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회한다.  

설정 방법: @ManyToOne(fetch = FetchType.LAZY)  


## 즉시 로딩  

즉시 로딩(EAGER LOADING)을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.EAGER로 지정한다.  

```java
@Entity
public class Player {
    ...

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "team_id")
    private Team team;

    ...
}


// 즉시 로딩 실행 코드
Player player = em.find(Player.class, 1L);
Team team = player.getTeam(); // 객체 그래프 탐색
```  


예제 코드를 살펴보면 @ManyToOne 애노테이션에 fetch 속성의 값으로 FetchType.EAGER 값을 줬다. 이는 즉시 로딩으로 설정하는 값이다.  

따라서 em.find(Player.class, 1L)로 선수를 조회하는 순간 팀도 함께 조회한다.  

선수와 팀을 두 개의 테이블을 조회해야 하므로 쿼리를 2번 실행할 것 같지만  

대부분의 JPA의 구현체는 **즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용한다.**  

이후 player.getTeam()을 호출하면 이미 로딩된 팀1 엔티티를 반환한다.  





---

#### 출처  
- **자바 ORM 표준 JPA 프로그래밍 김영한 저**  
- **인프런: 자바 ORM 표준 JPA 프로그래밍 - 기본편**  