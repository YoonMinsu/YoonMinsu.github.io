---
title   : "플러시"
categories : 
    - jpa
tags : 
    - java
    - spring
    - jpa
sidebar:
    title: "JPA"
    nav : sidebar-posts
---  

**플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다**  

플러시를 실행하게 되면  

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 생성해 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다(등록, 수정, 삭제 쿼리)

영속성 컨텍스트를 플러시하는 3가지 방법  
- em.flush()를 직접 호출
- 트랜잭션 커밋 시 플러시가 자동 호출
- JPQL 쿼리 실행 시 플러시가 자동 호출

#### 직접 호출  

엔티티 매니저의 flush() 메소드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시한다.  

테스트 또는 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용하지 않는다.  


#### 트랜잭션 커밋 시 플러시 자동 호출  

데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다.  

트랜잭션을 커밋하기 전에 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영해야 한다.  

JPA는 위와 같은 문제를 예방하기 위해 트랜잭션을 커밋할 때 플러시를 자동으로 호출한다.  

#### JPQL 쿼리 실행 시 플러시 자동 호출  

JPQL이나 Criteria같은 객체 지향 쿼리를 호출할 때도 플러시가 실행된다.  

```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

query = em.createQuery("select m form Member m", Member.class);

List<Member> member = query.getResultList();
```  

em.persist() 메서드를 사용해 memberA, B, C를 영속 상태로 만들었다.  

위 3개 엔티티는 영속성 컨텍스트에 있지만 아직 데이터베이스에는 반영되지 않은 상태이다.  

JPQL은 SQL로 변환되어 데이터베이스에서 데이터를 조회한다. 그런데 엔티티들은 아직 데이터베이스에 존재하지 않아서 쿼리 결과로 조회되지 않는다.  

따라서 **쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해 변경 내용을 데이터베이스에 반영해야 한다**  

JPA는 이런 문제를 예방하기 위해 JPQL을 실행할 때 플러시를 자동으로 호출한다.  

memberA, B, C도 쿼리 결과에 포함된다.  

## 플러시 모드 옵션  

엔티티 매니저에 플러시 모드를 직접 지정하려면 *javax.persistence.FlushModeType*을 사용하면 된다.  

- FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시한다(기본 값)  
- FlushModeType.COMMIT: 커밋할 때만 플러시  

플러시 모드를 따로 설정하지 않으면 기본 값(AUTO)로 동작한다.  

트랜잭션 커밋이나 쿼리 실행 시에 플러시를 자동으로 호출한다. 대부분 AUTO 기본 설정을 그대로 사용한다.  

`em.setFlushMode(FlushModeType.COMMIT)` 플러스 모드 직접 설정  

플러시라는 이름이 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 절대 안된다.  

**플러시는 데이터베이스에 동기화하는 것이다**  

데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다.  

트랜잭션 직전에만 변경 내용을 데이터베이스에 보내 동기화하면 된다.  

---

#### 출처  
- **자바 ORM 표준 JPA 프로그래밍 김영한 저**  
- **인프런: 자바 ORM 표준 JPA 프로그래밍 - 기본편**  