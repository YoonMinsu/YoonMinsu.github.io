---
title   : "객체 지향 설계 5원칙"
categories : 
    - Java
tags : 
    - java
sidebar:
    title: "Java"
    nav : sidebar-posts
---  

객체 지향 언어의 시초라고 하는 Simula67이 1960년에 발표되고 50년 이상의 세월이 흘렀다. 그 세월 동안 수많은 시행착오와 베스트 프랙티스 속에서 객체 지향 설계(OOD, Object Oriented Design)의 정수라고 할 수 있는 5원칙이 집대됐는데 바로 SOLID이다. SOLID는 로버트 C. 마틴이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 마이클 페더스가 두문자어로 소개한 것이다. SOLID는 아래 5가지 원칙의 앞 머리 알파벳을 따서 부르는 이름이다.  

1. __SRP(Single Responsibility Principle): 단일 책임 원칙__
2. __OCP(Open Cloesd Principle): 개방 폐쇄 원칙__
3. __LSP(Liskov Substitution Principle): 리스코프 치환 원칙__
4. __ISP(Interface Segregation Principle): 인터페이스 분리 원칙__
5. __DIP(Depedency Inversion Principle): 의존 역전 원칙__

이 원칙들은 응집도는 높이고(High Cohesion), 결합도는 낮추라(Loose Coupling)는 고전 원칙을 객체 지향의 관점에서 재정립한 것이라고 할 수 있다.  

>__결합도와 응집도__
>좋은 소프트웨어 설계를 위해서는 결합도(Coupling)는 낮추고 응집도(Cohesion)는 높은 것이 바람직하다.
>
>결합도는 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
>응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아셔 재사용이나 기능의 수정, 유지보수가 용이하다.

<br/>

## SRP - 단일 책임의 원칙  

__어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다 - 로버트 C. 마틴__  


한 클래스에는 하나의 책임만 가지게 설계하는 것이 좋다.  

객체가 여러 책임을 갖게 되면 해당 객체는 각 책임마다 변경되는 이유가 발생하기 때문에, 객체가 한 개의 이유로만 변경되려면 객체는 한 개의 책임만을 가져야 한다.  

하나의 책임만을 담당하면 변경 시, 그 책임만 변경 하면 되고 결과적으로 결합도를 줄여서 유지보수 비용이 줄어든다.  

만약에 어떤 클래스에 다양한 기능들이 있다면 결합도가 높을 것이고, 기능에 변화가 생기면 다른 기능에도 영향을 주어 많은 수정을 해야한다는 점이 있다.  

## OCP - 개방 폐쇄 원칙  

__소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다 - 로버트 C. 마틴__  

즉, "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다"  

__다형성을 활용해보자__  
기름차를 타고다닌다고 생각해보자 돈을 벌어 전기차로 차를 바꿨는데 운전법을 다시 배워야 하는가? 그건아니다. 우리가 기름차를 타다가 전기차를 탄다고 해서 운전을 다시 배워야 하는건 아니다. 무슨 자동차를 타든 운전자는 운전법만 알고 있으면 된다.  

```java
interface 자동차 {
    ...
}

class 쏘나타 implemetns 자동차 {
    ...
}

class 테슬라 implemntes 자동차 {
    ...
}
```  

상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 운전자는 운전하는 법을 다시 안 배워도 된다. 다양한 자동차가 생긴다는 것은 자신의 확장에는 개방되어 있는 것이고, 운전자 입장에서는 변화에 폐쇄되어 있는 것이다.  

물론 OCP를 따르지 않는다고 해서 프로그램 구현이 불가능한 것은 아니지만  

OCP를 무시하고 작성하면 객체 지향 프로그래밍의 큰 장점인 유연성, 유지 보수, 재사용성 등을 얻을 수가 없다.  

## LSP - 리스코프 치환 원칙  

__서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다 - 로버트 C. 마틴__  

(추가 예정)


## ISP - 인터페이스 분리 원칙  

__클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다 - 로버트 C. 마틴__  

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.  

즉 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말하야 한다.  

자동차 인터페이스에 운전기능과 정비기능이 있다고 해보자 하나의 인터페이스에 너무 많은 기능이 들어 있는 것보다 운전 인터페이스와 정비 인터페이스로 분리하게 되면 사용자 클라이언트를 운전자 클라이언트와, 정비사 클라이언트로 분리할 수 있다. 분리하면 정비 인터페이스 자체가 변하도 운전자 클라이언트에 영향을 주지 않는다.  

인터페이스가 명확해지고, 대체 가능성이 높아진다.

## DIP - 의존 역전 원칙  

__고차원 모듈은 저차원 모듈에 의존하면 안된다.__  
__이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.__  
__추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.__  
__자주 변경되는 구체 클래스에 의존하지마라 - 로버트 C. 마틴__  

구현 클래스에 의존하지말고, 인터페이스에 의존하라는 뜻이다.  

상위 클래스일수록, 인터페이스일수록 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 의존 역전 원칙이다.  


## 정리  

SOLID는 객체 지향을 올바르게 프로그램에 녹여내기 위한 원칙이다.  

SOLID를 이야기할 때 빼놓을 수 없는 것이 SoC다. SoC는 관심사의 분리(Separation Of Concerns)의 머리글자이다.  

관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것이다.  

하나의 속성, 메서드, 클래스, 모듈 또는 패키지에는 하나의 관심사만 들어 있어야 한다는 것이 SoC다.  

스프링 또한 SoC를 통해 SOLID를 극한 까지 적용하고 있다.  

__SOLID__  
- SRP(단일 책임 원칙): 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.  
- OCP(개방 폐쇄 원칙): 자신의 확장에는 열려 있고 주변의 변화에 대해서는 닫혀 있어야 한다.  
- LSP(리스코프 치환 원칙): 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.  
- ISP(인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.  
- DIP(의존 역전 원칙): 자신보다 변하기 쉬운 것에 의존하면 안된다.  

---

참조  
- 스프링 입문을 위한 자바 객체지향의 원리와 이해
- 인프런 스프링 핵심 원리 - 기본편

