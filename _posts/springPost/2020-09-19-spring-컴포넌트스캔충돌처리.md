---
title   : "컴포넌트 스캔에 따른 충돌 처리"
excerpt : "초보 웹 개발자를 위한 스프링5 프로그래밍 입문 - 최범균 저"
categories : 
    - Spring
tags : 
    - Spring
    - Web
sidebar:
    title: "Spring"
    nav : sidebar-posts
---    

컴포넌트 스캔 기능을 사용해서 자동으로 Bean을 등록할 때에는 충돌에 주의해야 한다.  
크게 Bean 이름 충돌과 수동 등록에 따른 충돌이 발생할 수 있다.  

### Bean 이름 출돌  
```java
@Configuration
@ComponentScan(basePackages = {"spring", "spring2"})
public class ApplicationConfig {
    ....
}
```
spring 패키지와 spring2 패키지에 MemberRegisterService 클래스가 존재하고 두 클래스에 모두 @Component 애노테이션을 붙였다고 가정하자 이 상태에서 @ComponentScan을 사용하면 에러가 발생한다.  

컴포넌트 스캔 과정에서 서로 다른 타입인데 같은 Bean 이름을 사용하는 경우가 있다면 둘 중 하나에 명시적으로 Bean 이름을 지정해 이름 충돌을 피해야 한다.  

#### 수동 등록한 Bean과 충돌  

```java
@Component
public class MemberDao {
    ...
}
```
위 MemberDao 클래스는 컴포넌트 스캔 대상이다. 자동 등록된 Bean의 이름은 클래스 이름의 첫 글자를 소문자로 바꾼 "memberDao"이다. 그런데 설정 클래스에 직접 MemberDao클래스를 "memberDao"라는 이름의 빈으로 등록하면 어떻게 될까?  
```java
@Configuration
@CompoenetScan(basePackages = {"spring"})
public class ApplicationConfig {
    @Bean
    public MemberDao memberDao() {
        return new MemberDao();
    }
}
```  
__스캔할 때 사용하는 Bean 이름과 수동 등록한 Bean 이름이 같은 경우 수동 등록한 Bean이 우선 한다.  
즉 MemeberDao 타입 Bean은 ApplicationConfig에서 정의한 한 개만 존재한다.__  

다른 이름을 사용하면 어떻게 될까?  
```java
@Configuration
@CompoenetScan(basePackages = {"spring"})
public class ApplicationConfig {
    @Bean
    public MemberDao memberDao2() {
        return new MemberDao();
    }
}
```  
이 경우 스캔을 통해 등록한 "memberDao" Bean과 수동 등록한 "memberDao2"의 Bean이 모두 존재한다.  
MemberDao 타입의 빈이 두 개가 생성되므로 자동 주입하는 코드는 __@Qualifier__ 애노테이션을 사용해서 알맞은 Bean을 선택해야 한다.