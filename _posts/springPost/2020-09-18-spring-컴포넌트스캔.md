---
title   : "컴포넌트 스캔"
excerpt : "초보 웹 개발자를 위한 스프링5 프로그래밍 입문 - 최범균 저"
categories : 
    - Spring
tags : 
    - Spring
    - Web
sidebar:
    title: "Spring"
    nav : sidebar-posts
---    

컴포넌트 스캔은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다.  
설정 클래스에서 빈으로 등록하지 않아도 원하는 클래스를 빈으로 등록할 수 있으므로  
컴포넌트 스캔을 사용하면 설정 코드가 크게 줄어든다.  


### @Component 애노테이션으로 스캔 대상 지정  

스프링이 검색해서 Bean으로 등록할 수 있으려면 클래스에 `@Component` 애노테이션을 붙이면 된다.  
`@Component` 애노테이션은 해당 클래스를 스캔 대상으로 표시한다.  

@Component 애노테이션에 값을 주었는지에 따라 Bean으로 등록할 때 사용할 이름이 결정된다.  
값을 주지 않을 경우 __클래스 이름의 첫 글자를 소문자로 바꾼 이름__ 을 Bean 이름으로 사용한다.  
ex) 클래스 이름이 MemberDao이면 bean이름으로 memberDao를 사용한다.  

@Component 애노테이션에 값을 주면 그 값을 Bean이름으로 사용한다.  
```java
// "listPrinter"를 Bean이름으로 사용한다.
@Component("listPrinter")
public class MemberListPrinter {
    private MemberDao memberDao;
    private MemberPrinter memberPrinter;

    ...
}
```

### @ComponentScan 애노테이션으로 스캔 설정  
@Component 애노테이션을 붙인 클래스를 스캔해서 스프링 빈으로 등록하려면 설정 클래스에 @ComponentScan 애노테이션을 적용해야 한다.  

```java
@Configuration
@ComponentScan(basePackages = {"spring"})
public class ApplicationConfig {
    ...
}
```
위 설정 클래스의 @ComponentScan 애노테이션의 basePackages 속성값은 __{"spring"}__ 이다.  
이 속성은 __스캔 대상 패키지 목록을 지정__ 한다. 값에는 {"spring"} 하나 뿐인데 이는 `spring  패키지와 그 하위 패키지에 속한 클래스를 스캔 대상으로 설정`한다.  
스캔 대상 해당하는 클래스 중에서 @Component 애노테이션이 붙은 클래스의 객체를 생성해 Bean으로 등록한다.  
물론 @Component 애노테이션을 붙인 클래스만 컴포넌트 스캔 대상에 포함되는 것은 아니다
__기본 스캔 대상__  
- __@Component__(org.springframework.stereotype 패키지)
- __@Controller__(org.springframework.stereotype 패키지)
- __@Service__(org.springframework.sterotype 패키지)
- __@Repository__(org.springframework.stereotype 패키지)  
- __@Aspect__(org.aspectj.lang.annotation 패키지)
- __@Configuration__(org.springframework.context.annotation 패키지)  
  

### 스캔 대상에서 제외하기  
excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.  

```java
// 동일 코드에 대하여 정규표현식 / AspectJ 패턴 사용 방식
 // 정규표현식을 이용한 1번째 방법
 @Configuration
 @ComponentScan(basePackages = {"spring"}, 
     excludeFilters = 
             (@Filter(type = FilterType.REGEX, pattern = "spring\\..*Dao" )		
 )

 // AspectJ를 이용한 2번째 방법
 @Configuration
 @ComponentScan(basePackages = {"spring"}, 
     excludeFilters = 
             (@Filter(type = FilterType.ASPECTJ, pattern = "spring.*Dao" )		
 )

 public class AppCtxWithExclude {
     ...
 }
```  
@Filter 애노테이션의 type 속성 값으로 FilterType.REGEX를 주었다. 이는 정규표현식을 사용해 제외 대상을 지정한다는 것을 의미한다. pattern 속성은 FilterType에 적용할 값을 설정한다.  
위 설정에서는 __"spring."으로 시작하고 Dao로 끝나는 정규표현식을 지정__ 했으므로 spring.MemberDao와 같은 클래스는 컴포넌트 스캔 대상에서 제외한다.  

AspectJ 패턴은 spring패키지에서 Dao로 끝나는 타입을 컴포넌트 스캔 대상에서 제외한다.  
AspectJ 패턴이 동작하려면 의존 대상에 __aspectjweaver__ 모듈을 추가해야 한다.

__특정 애노테이션을 붙인 다음 컴포넌트 대상에서 제외__  
```java
 @Retention(RUNTIME)
 @Target(TYPE)
 public @interface NoProduct {

 }

 @Retention(RUNTIME)
 @Target(TYPE)
 public @interface ManualBean {

 }
```  
@Retention과 @Target 애노테이션을 붙인 클래스를 컴포넌트 스캔 대상에서 제외하려면 밑과 같이 한다.  
```java
 @Configuration
 @ComponentScan(basePackages = {"spring"}, 
     excludeFilters = { 
             @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class )			
 })
```  

type 속성 값으로 FilterType.ANNOTATION을 사용하면 classes 속성에 필터로 사용할 애노테이션 타입을 값으로 준다.  

특정 타입이나 그 하위 타입을 컴포넌트 스캔 대상에서 제외하려면 ASSIGNABLE_TYPE을 FilterType으로 사용한다.  
```java
@Configuration
@ComponentScan(basePackages = {"spring"}, 
 excludeFilters = { 
         @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MemberDao.class )			
})
```

classes 속성에는 제외할 타입 목록을 지정한다.  


설정할 필터가 두 개 이상이면 @ComponentScan의 excludeFilters 속성에 배열을 사용해 @Filter 목록을 전달하면 된다.  
```java
 @Configuration
 @ComponentScan(basePackages = {"spring"}, 
     excludeFilters = { 
             @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class ),
             (@Filter(type = FilterType.REGEX, pattern = "spring\\..*Dao" )
 })
```