---
title   : "[BOJ] 2178번: 미로 탐색"
excerpt : "PS"
categories : 
    - boj
tags : 
    - ps
    - dfs
    - bfs
sidebar:
    title: "BaekJoon"
    nav : sidebar-posts
---  

미로 탐색 문제이다.  

출발 지점은 (1, 1)에서 도착 지점(n, m) 까지의 최소 거리를 구하면 된다.  

최소 거리를 구하는 문제이니 DFS보단 BFS가 적합하다.  

```java
import java.awt.Point;
import java.io.*;
import java.util.*;

class BaekJoon_2178 {
    private final int[] dx = {-1, 1, 0, 0};
    private final int[] dy = {0, 0, -1, 1};
    private int n, m;

    /* 미로 초기화 */
    private int[][] initMaze(BufferedReader br, int n, int m) throws IOException {
        int[][] maze = new int[n][m];
        for (int i = 0; i < n; ++i) {
            String[] list = br.readLine().split("");
            for (int j = 0; j < m; ++j) {
                maze[i][j] = Integer.parseInt(list[j]);
            }
        } // end for
        return maze;
    }

    /* 탐색 과정에서 범위를 벗어나지 않는지 검사 */
    private boolean checkLocation(int x, int y, int[][] maze, boolean[][] visited) {
        if (x >= 0 && y >= 0 && x < n && y < m) {
            return maze[x][y] == 1 && !visited[x][y];
        }
        return false;
    }

    /* 너비 우선 탐색*/
    private void BFS(int x, int y, int[][] maze, boolean[][] visited) {
        Queue<Point> q = new LinkedList<>();
        visited[x][y] = true;
        q.offer(new Point(x, y));

        while (!q.isEmpty()) {
            Point now = q.poll();

            // 4방향 탐색 (위, 아래, 왼쪽, 오른쪽)
            for (int i = 0; i < 4; ++i) {
                int nextX = now.x + dx[i];
                int nextY = now.y + dy[i];

                if (checkLocation(nextX, nextY, maze, visited)) {
                    visited[nextX][nextY] = true;
                    q.offer(new Point(nextX, nextY));
                    maze[nextX][nextY] = maze[now.x][now.y] + 1;
                } // end if
            } // end for
        } // end while
    }

    public void run() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] list = br.readLine().split(" ");

        n = Integer.parseInt(list[0]);
        m = Integer.parseInt(list[1]);

        boolean[][] visited = new boolean[n][m];
        int[][] maze = initMaze(br, n, m);

        // 배열의 인덱스는 0부터 시작하므로 0,0을 탐색 위치로 주었다
        BFS(0,0, maze, visited);

        System.out.println(maze[n - 1][m - 1]);
    }
}

public class Main {
    public static void main(String[] args) throws IOException {
        new BaekJoon_2178().run();
    }
}
```  

예제1번을 BFS과정을 진행하고 나면 미로의 상태는 아래와 같이 바뀐다.  

![img](/assets/img/ps/2178_result.PNG)  

(N, M) 까지의 최소 거리를 구하는 거니 `System.out.println(maze[n - 1][m - 1]);` 을 해주면 결과를 구할 수 있다.