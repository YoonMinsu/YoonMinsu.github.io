---
title   : "최장 증가 수열(1)"
excerpt : "Dynamic Programming"
categories : 
    - Algorithm
tags : 
    - algorithm
    - dp
sidebar:
    title: "Algorithm"
    nav : sidebar-posts
---
다이나믹 프로그래밍을 통해 해결 할 수 있다.  

### 부분 수열  
- 어떠한 수열에서 일부 숫자를 제거해 새로 만들 수 있는 수열을 말한다.  
<br/>

### 가장 긴 증가하는 부분 수열  
- 어떠한 수열의 부분 수열이면서 오름차순이고, 길이가 가장 긴 수열을 말한다.  
<br/>

O(n^2) and O(n log n) 방법이 있다.  


### O(n^2)  
dp[ i ] = i번째 원소를 마지막으로 하는 LIS의 길이를 뜻한다.  

```java
public static int lengthOFLIS( int[] nums ) {  
    // nums는 어떠한 수열의 데이터가 들어있는 배열이다.  
    // dp[i] = i번째 원소를 마지막으로 하는 LIS의 길이
    int[] dp = new int[ nums.length ];
    dp[0] = 1; // 데이터가 1개 들어있을 때 최대 길이는 1이다.  

    // 1 부터 nums 배열의 길이까지 탐색해준다.
    for ( int i = 1; i < nums.length; ++i ) {
        int len = 0;
        // i를 기준으로 인덱스 0부터 i - 1 까지 체크해준다.
        // 하나를 기준으로 잡아 루프를 돌게 된다. ( nums[ i ] )
        for ( int j = 0; j < i; ++j ) {
            // 최장 증가 수열이니 기준으로 잡은 nums[ i ]는 nums[ j ]보다 커야한다.
            // 가장 긴 길이를 구해야 하므로 기존에 있던 len의 값보다 더 큰 값이 들어오게 되면 갱신해줘야 한다.
            if ( nums[ i ] > nums[ j ] && dp[ j ] > len ) {
                len = dp[ j ];
            }
        }
        dp[ i ] = len + 1;
    } 

    // dp배열은 i번째 원소를 마지막으로 하는 LIS의 길이가 있다 
    // i번째를 포함하는 길이가 최대가 아닐 수도 있다.
    int maxLength = 0;
    for ( int i = 0; i < nums.length; ++i ) {
        maxLength = Math.max( maxLength, dp[ i ] );
    } 
    return maxLength;
}
```  
관련 문제 링크  
[BaekJoon_11053 가장 긴 증가하는 부분 수열]<https://www.acmicpc.net/problem/11053>  
[BaekJoon_11055 가장 큰 증가 부분 수열]<https://www.acmicpc.net/problem/11055>  
[BaekJoon_1965 상자 넣기]<https://www.acmicpc.net/problem/1965>  